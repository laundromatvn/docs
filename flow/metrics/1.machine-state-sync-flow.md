# Machine State Sync Flow Documentation

## Introduction

This document describes the flow for reporting machine state from controllers to the backend. Controllers periodically send their current machine states to the backend for monitoring and tracking purposes.

**Flow Overview:**
1. Controller sends machine state to backend

## MQTT Topic

### Controller to Backend Topic
Controllers send machine state to:
```
/stores/<store_id>/controllers/<controller_id>/metrics
```

Where:
- `<store_id>` is the UUID of the store
- `<controller_id>` is the UUID of the controller

## Schema

### Machine State Message
```json
{
  "version": "string",
  "event_type": "string",
  "timestamp": "string",
  "correlation_id": "string",
  "controller_id": "string",
  "store_id": "string",
  "payload": "object"
}
```

## Field Descriptions

### Machine State Message Fields

#### `event_type`
- **Type:** `string`
- **Format:** Enum value
- **Purpose:** Identifies the type of state message
- **Values:** 
  - `"machine_state"` - Controller reporting current machine states
- **Required:** Yes

#### `payload`
- **Type:** `object`
- **Format:** JSON object
- **Purpose:** Contains current machine states
- **Required:** Yes
- **Structure:**
  ```json
  {
    "machines": [
      {
        "machine_type": "washer | dryer | null",
        "relay_id": "number",
        "status": "idle | busy",
        "last_updated": "string"
      }
    ]
  }
  ```
- **Fields:**
  - `machines`: Array of machine state objects
  - `machine_type`: Type of machine (`"washer"`, `"dryer"`, or `null` - optional)
  - `relay_id`: ID of the relay controlling the machine
  - `status`: Current status of the machine (`"idle"` or `"busy"`)
  - `last_updated`: ISO timestamp when the state was last updated


## Flow Steps

### Step 1: Controller Sends Machine State
Controller periodically sends current machine states to the backend:

**Machine State Message:**
```json
{
  "version": "1.0.0",
  "event_type": "machine_state",
  "timestamp": "2024-01-15T16:00:00+07:00",
  "correlation_id": "550e8400-e29b-41d4-a716-446655440004",
  "controller_id": "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
  "store_id": "6ba7b811-9dad-11d1-80b4-00c04fd430c8",
  "payload": {
    "machines": [
      {
        "machine_type": "washer",
        "relay_id": 1,
        "status": "busy",
        "last_updated": "2024-01-15T15:58:30+07:00"
      },
      {
        "machine_type": null,
        "relay_id": 2,
        "status": "idle",
        "last_updated": "2024-01-15T15:45:15+07:00"
      }
    ]
  }
}
```


## State Reporting Patterns

### Periodic State Reporting
- Controllers send state updates at regular intervals (e.g., every 30 seconds)
- Ensures backend has current machine status
- Helps detect offline controllers or communication issues

### Event-Driven Updates
- Controllers send immediate state updates when machine status changes
- Provides real-time status to backend
- Enables responsive UI updates

## Error Handling

### Communication Failures
- Controllers should retry failed state transmissions
- Backend should handle missing state updates gracefully
- Implement timeout mechanisms for state reporting

### State Validation
- Backend should validate received state data
- Log invalid states for debugging and analysis
- Handle malformed state messages gracefully

### Invalid States
- Validate machine states before processing
- Ensure status is either "idle" or "busy"
- machine_type can be null if not specified
- Provide clear error messages for debugging

## Performance Considerations

### Message Frequency
- Balance between real-time updates and system load
- Use appropriate intervals for periodic reporting
- Implement adaptive frequency based on system load

### Message Size
- Keep state messages concise
- Only include necessary state information
- Consider compression for large state payloads

### Network Efficiency
- Batch multiple state updates when possible
- Use delta updates to reduce message size
- Implement message queuing for reliability
